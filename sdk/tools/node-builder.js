// citadel-agent/sdk/tools/node-builder.js
/**
 * Node Builder - CLI Tool for Generating Custom Nodes
 * Provides scaffolding for new node development
 */

const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');

class NodeBuilder {
  constructor(options = {}) {
    this.options = {
      templateDir: options.templateDir || path.join(__dirname, '../templates'),
      outputDir: options.outputDir || './nodes',
      ...options
    };
  }

  /**
   * Creates a new node with full boilerplate
   */
  async createNode(name, options = {}) {
    const nodeDir = path.join(this.options.outputDir, name.toLowerCase());
    
    // Validate node name
    if (!this.isValidNodeName(name)) {
      throw new Error(\`Invalid node name: \${name}. Use alphanumeric characters and underscores only.\`);
    }

    // Create directory structure
    await this.createDirectoryStructure(nodeDir);

    // Generate node definition
    const nodeDefinition = this.createNodeDefinition(name, options);
    await fs.writeFile(
      path.join(nodeDir, 'node.json'),
      JSON.stringify(nodeDefinition, null, 2)
    );

    // Generate main node file
    const nodeCode = this.generateNodeClass(name, options);
    await fs.writeFile(
      path.join(nodeDir, 'index.js'),
      nodeCode
    );

    // Generate package.json
    const packageJson = this.generatePackageJson(name, options);
    await fs.writeFile(
      path.join(nodeDir, 'package.json'),
      JSON.stringify(packageJson, null, 2)
    );

    // Generate tests
    const testCode = this.generateTestFile(name, options);
    await fs.writeFile(
      path.join(nodeDir, 'test', 'index.test.js'),
      testCode
    );

    // Generate documentation
    const readme = this.generateReadme(name, options);
    await fs.writeFile(
      path.join(nodeDir, 'README.md'),
      readme
    );

    // Generate examples
    const example = this.generateExample(name, options);
    await fs.writeFile(
      path.join(nodeDir, 'examples', 'usage.js'),
      example
    );

    console.log(\`‚úÖ Successfully created node: \${name}\`);
    console.log(\`üìÅ Location: \${nodeDir}\`);
    console.log(\`üìù Don't forget to register your node in the registry!\`);
    
    return nodeDir;
  }

  /**
   * Creates the directory structure for a node
   */
  async createDirectoryStructure(nodeDir) {
    const dirs = [
      nodeDir,
      path.join(nodeDir, 'lib'),
      path.join(nodeDir, 'test'),
      path.join(nodeDir, 'examples'),
      path.join(nodeDir, 'docs')
    ];

    for (const dir of dirs) {
      await fs.mkdir(dir, { recursive: true });
    }
  }

  /**
   * Creates node definition object
   */
  createNodeDefinition(name, options) {
    return {
      id: name.toLowerCase().replace(/\s+/g, '_'),
      name: name,
      description: options.description || 'A custom node for Citadel Agent',
      version: options.version || '1.0.0',
      author: options.author || process.env.USER || 'Anonymous',
      category: options.category || 'custom',
      grade: options.grade || 'basic', // basic, intermediate, advanced, elite
      type: 'custom',
      icon: options.icon || 'custom',
      tags: options.tags || [],
      dependencies: options.dependencies || [],
      schema: {
        inputs: options.inputs || [],
        outputs: options.outputs || [],
        config: options.config || {}
      },
      documentation: {
        usage: options.usage || 'Describe how to use this node',
        examples: [],
        changelog: [{
          version: '1.0.0',
          date: new Date().toISOString(),
          changes: 'Initial release'
        }]
      }
    };
  }

  /**
   * Generates the main node class
   */
  generateNodeClass(name, options) {
    // Capitalize first letter for class name
    const className = this.toPascalCase(name);
    
    return `/**
 * ${name} Node
 * ${options.description || 'Custom node implementation'}
 * Generated by Citadel Agent Node Builder
 */

const { NodeExecutor } = require('@citadel-agent/core');

class ${className}Node extends NodeExecutor {
  constructor(config) {
    super();
    this.config = this.validateAndMergeConfig(config);
    this.initialized = false;
    this.stats = {
      executions: 0,
      errors: 0,
      avgExecutionTime: 0
    };
  }

  /**
   * Validates and merges configuration with defaults
   */
  validateAndMergeConfig(config) {
    const defaults = {
      // Define default configuration values here
      enabled: true,
      timeout: 30000,
      retryAttempts: 3,
      ...config
    };

    // Add validation logic here
    if (defaults.timeout && defaults.timeout < 1000) {
      throw new Error('Timeout must be at least 1000ms');
    }

    return defaults;
  }

  /**
   * Initializes the node, setting up any required resources
   */
  async initialize() {
    if (this.initialized) return;

    try {
      // Initialize any required resources here
      // e.g., database connections, API clients, etc.
      
      this.initialized = true;
      console.log('[${name}] Initialized successfully');
    } catch (error) {
      console.error(\`[${name}] Initialization failed:\`, error);
      throw error;
    }
  }

  /**
   * Validates the node configuration
   */
  validateConfig() {
    const errors = [];
    
    // Add custom validation logic here if needed
    
    return errors;
  }

  /**
   * Main execution method
   * @param {Object} input - Input data from previous nodes
   * @returns {Promise<Object>} - Execution result
   */
  async execute(input) {
    // Start timing
    const startTime = Date.now();
    
    try {
      await this.initialize();
      this.stats.executions++;

      console.log(\`[${name}] Executing with input:\`, input);

      // Perform the actual work
      const result = await this.process(input);

      // Update stats
      const executionTime = Date.now() - startTime;
      this.updateStats(executionTime);

      return {
        status: 'success',
        data: result,
        metadata: {
          executionTime: executionTime,
          node: this.constructor.name,
          timestamp: new Date().toISOString()
        }
      };
    } catch (error) {
      this.stats.errors++;
      console.error(\`[${name}] Execution error:\`, error);

      return {
        status: 'error',
        error: error.message,
        stack: error.stack,
        metadata: {
          executionTime: Date.now() - startTime,
          node: this.constructor.name,
          timestamp: new Date().toISOString()
        }
      };
    }
  }

  /**
   * Core processing logic - override this method in subclasses
   */
  async process(input) {
    // Default implementation - override this in your custom node
    return {
      message: 'Node executed successfully',
      input: input,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Updates execution statistics
   */
  updateStats(executionTime) {
    // Simple moving average for execution time
    this.stats.avgExecutionTime = (this.stats.avgExecutionTime * (this.stats.executions - 1) + executionTime) / this.stats.executions;
  }

  /**
   * Gets node statistics
   */
  getStats() {
    return { ...this.stats };
  }

  /**
   * Cleans up resources when node is destroyed
   */
  async destroy() {
    if (!this.initialized) return;

    // Clean up any resources here
    // e.g., close database connections, stop timers, etc.

    this.initialized = false;
    console.log(\`[${name}] Cleaned up resources\`);
  }
}

module.exports = { ${className}Node };
`;
  }

  /**
   * Generates package.json for the node
   */
  generatePackageJson(name, options) {
    return {
      name: \`@citadel-agent/node-\${name.toLowerCase()}\`,
      version: options.version || '1.0.0',
      description: options.description || `Citadel Agent node for ${name}`,
      main: 'index.js',
      scripts: {
        test: 'jest',
        build: 'echo "Build script goes here"',
        lint: 'eslint .'
      },
      keywords: [
        'citadel-agent',
        'node',
        `${name.toLowerCase()}`
      ],
      author: options.author || process.env.USER || 'Anonymous',
      license: 'MIT',
      dependencies: {
        '@citadel-agent/core': '^1.0.0'
      },
      devDependencies: {
        'jest': '^29.0.0',
        'eslint': '^8.0.0'
      },
      citadelAgent: {
        node: true
      }
    };
  }

  /**
   * Generates test file for the node
   */
  generateTestFile(name, options) {
    const className = this.toPascalCase(name);
    
    return `/**
 * Tests for ${name} Node
 */

const { ${className}Node } = require('../index');

describe('${name}Node', () => {
  let node;

  beforeEach(() => {
    node = new ${className}Node({
      // Add test configuration here
    });
  });

  afterEach(async () => {
    if (node.destroy) {
      await node.destroy();
    }
  });

  test('should create node instance', () => {
    expect(node).toBeInstanceOf(${className}Node);
  });

  test('should execute successfully with valid input', async () => {
    const input = { test: 'data' };
    const result = await node.execute(input);
    
    expect(result).toHaveProperty('status');
    expect(result.status).toBe('success');
    expect(result).toHaveProperty('data');
  });

  test('should handle error cases', async () => {
    const input = null;
    const result = await node.execute(input);
    
    // Expect either success or error status (depending on error handling)
    expect(['success', 'error']).toContain(result.status);
  });

  test('should return proper statistics', () => {
    const stats = node.getStats();
    expect(stats).toHaveProperty('executions');
    expect(stats).toHaveProperty('errors');
    expect(stats).toHaveProperty('avgExecutionTime');
  });
});
`;
  }

  /**
   * Generates README for the node
   */
  generateReadme(name, options) {
    return `# ${name} Node

${options.description || 'A custom node for Citadel Agent'}

## Description

This node provides functionality for ${name.toLowerCase()}. It integrates with the Citadel Agent workflow engine to provide advanced automation capabilities.

## Features

- Feature 1
- Feature 2
- Feature 3

## Installation

\`\`\`bash
npm install @citadel-agent/node-${name.toLowerCase()}
\`\`\`

## Configuration

### Parameters

| Parameter | Type | Required | Description |
| --------- | ---- | -------- | ----------- |
| example_param | string | No | Example configuration parameter |

### Schema

\`\`\`json
{
  "type": "object",
  "properties": {
    "enabled": {
      "type": "boolean",
      "default": true,
      "description": "Enable/disable the node"
    }
  }
}
\`\`\`

## Usage

### Basic Example

\`\`\`javascript
const { ${this.toPascalCase(name)}Node } = require('@citadel-agent/node-${name.toLowerCase()}');

const node = new ${this.toPascalCase(name)}Node({
  // Configuration options
});

const result = await node.execute({
  // Input data
});
\`\`\`

## Development

### Running Tests

\`\`\`bash
npm test
\`\`\`

### Building

\`\`\`bash
npm run build
\`\`\`

## License

MIT
`;
  }

  /**
   * Generates an example usage file
   */
  generateExample(name, options) {
    const className = this.toPascalCase(name);
    
    return `/**
 * Example usage of ${name} Node
 */

const { ${className}Node } = require('@citadel-agent/node-${name.toLowerCase()}');

async function example() {
  const node = new ${className}Node({
    // Configuration options
    enabled: true
  });

  const inputData = {
    // Sample input data
    example: 'data',
    value: 123
  };

  try {
    console.log('Executing ${name} node...');
    const result = await node.execute(inputData);
    
    console.log('Execution result:', result);
    
    if (result.status === 'success') {
      console.log('Success! Result data:', result.data);
    } else {
      console.error('Node execution failed:', result.error);
    }
  } catch (error) {
    console.error('Unexpected error:', error);
  } finally {
    // Clean up when done
    if (node.destroy) {
      await node.destroy();
    }
  }
}

// Run example if this file is executed directly
if (require.main === module) {
  example().catch(console.error);
}
`;
  }

  /**
   * Validates node name (alphanumeric and underscores only)
   */
  isValidNodeName(name) {
    return /^[a-zA-Z][a-zA-Z0-9_]*$/.test(name);
  }

  /**
   * Converts string to PascalCase
   */
  toPascalCase(str) {
    return str
      .split(/[^a-zA-Z0-9]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  /**
   * Lists available templates
   */
  listTemplates() {
    const templateDir = this.options.templateDir;
    if (!fs.existsSync(templateDir)) {
      return [];
    }
    
    return fs.readdirSync(templateDir).filter(file => 
      fs.statSync(path.join(templateDir, file)).isDirectory()
    );
  }
}

// CLI interface
if (require.main === module) {
  const { program } = require('commander');
  
  program
    .name('citadel-node-builder')
    .description('CLI tool for generating Citadel Agent nodes')
    .version('1.0.0');

  program
    .command('create <name>')
    .description('Create a new node')
    .option('-d, --description <desc>', 'Node description')
    .option('-a, --author <author>', 'Author name')
    .option('-c, --category <category>', 'Node category')
    .option('-g, --grade <grade>', 'Node grade (basic|intermediate|advanced|elite)')
    .option('-t, --tags <tags>', 'Comma-separated tags')
    .action(async (name, options) => {
      const builder = new NodeBuilder();
      
      const nodeOptions = {
        description: options.description,
        author: options.author,
        category: options.category,
        grade: options.grade,
        tags: options.tags ? options.tags.split(',') : []
      };

      try {
        await builder.createNode(name, nodeOptions);
        console.log(\`‚úÖ Node '\${name}' created successfully!\`);
      } catch (error) {
        console.error(\`‚ùå Error creating node: \`, error.message);
        process.exit(1);
      }
    });

  program.parse();
}

module.exports = { NodeBuilder };